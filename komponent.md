# Компонент

Повторно используемые компоненты создаются в директории components. В больших проектах создаются поддиректории для группировки компонентов по назначению, например: элементы форм, разметки, списки.

## Файловая структура компонента

Каждый компонент в своей папке. Название папки в соответствии с названием класса компонента в нижнем регистре через дефис \(kebbab стиль\).



В index.js или radio-button.js класс компонента. Расширение js

В style.less стили компонента. По умолчанию используем less, допустимы другие



* radio-button

* * index.js // допустимо radio-button.js

  * style.less



Название файлов и директорий всегда в нижнем регистре, чтобы избежать проблем с регистром на разных платформах. index.js рекомендуется для быстроты копипастов, единства внутренней структуры, коротких импортов. radio-button.js если в IDE/отладке неудобно различать файлы или index.js нужен для реэкспорта.

// На рассмотрении вариант UserWidget/UserWidget.js - где именование директории и файла в точности соответствует экспорту \(классу, функции - pascal обычно у классов, camleCase у функций\). Плюс в полной консистенции, а папка/файл с большой буквы - однозначное понимание, что там класс. Но проблемы с регистром, которые часто проявляются с файлами картинок или другими, где нет внутренних именований для автопроверки. И без изучения кода воспринимается как отсутствие правил именования.

В директории могут быть другие ресурсы компонента, в том числе вложенные компоненты, если они используются только в рамках компонента \(его составные части\).

Имя компонента начинается с обобщенного названия и последующими частями уточняется назначение/особенность компонента. Например: Button, ButtonNext, LayoutPage, MenuTop, FormNewsCreate. Польза в быстром улавливании сути компонентов, в упорядоченности файлов. Наличие правила упрощает придумывание имени. Хотя, есть противоречия грамматике английского языка и бывает режет слух, поэтому допустимы исключения. Например RadioButton общепринятое имя \(можно считать обобщенным названием\).

## Класс компонента

Компонент определяется через класс \(не функцию\), чтобы экономить время при доработки внутренней логики и иметь единую структуру всех компонент. Для оптимизации рендера использовать shouldComponentUpdate, React.PureComponent и не делать вычислений в render\(\)

Название класса всегда с большой буквы \(pascal стиль\)

```js
classMenuTopextend Component {

}

export MenuTop;
```



Описание входных свойств делать в начале класса статическим свойством propTypes вместо его присвоения после определения класса. Статических свойств нет в стандарте ES2016/2017, но через babel поддерживаются.

```
class MenuTop extend Component {

  static propTypes = {
    items: PropTypes.array
  }
}

```

## Стили класса

Использовать БЭМ. Название класса блока соответствует классу компонента в нижнем регистре: .menu-top и используется в первом теге. \(Рекомендуется использовать именование как у класса, т.е. с большой буквы. На практике экономия времени из-за консистентности\). Внутренняя разметка - это элементы, им названия классов через двойное подчеркивание. menu-top\_\_item. Для задания модификаций блоку или элементу использовать одно нижнее подчёркивание. radio-button\_classic \(https://ru.bem.info/methodology/naming-convention/\)

  


render\(\){

return \(

&lt;div className=”menu-top”&gt;

&lt;div className=”menu-top\_\_item”&gt;

  


&lt;/div&gt;

&lt;div className=”menu-top\_\_item menu-top\_\_item\_active”&gt;

  


&lt;/div&gt;

&lt;/div&gt;

\);

}

  


  


  


  


  


По БЭМ элементы есть только у блока. Элементов у элементов нету. Если по разметке что-то подобное напрашивается, то скорее всего речь идет о вложенном блоке. В простых случаях его можно определить css классом, но лучше подумать о выносе в отдельный react компонент.

  


Для указания нескольких классов или с условием использовать библиотеку classnames, импортируя её в короткую константу cs

  


import cs from “classnames”

  


&lt;div className={cs\(“menu-top\_\_item”, {“menu-top\_\_item\_disable”: disabled}\)}&gt;

## События \(callbacks\)

Функции обратного вызова, используемые для событий DOM/компонент, определять методами класса стрелочным способом. 

  


onClick = \(\) =&gt; {



};

  


В ряде случаях используется каррирование для замыкания параметра, определяемого при рендере. Тогда стрелочное определение метода не требуется.

  


onClick\(key\){

return \(e\) =&gt; {

e.preventDefault\(\);

this.prop.doSome\(key\);

}

}

  


&lt;li key={key} onClick={this.onClick\(key\)}&gt;&lt;/li&gt;

  


Нужно учитывать, что при каждом рендере будет создаваться новая функция-обработчик

  


Если внешний обработчик \(callback из props\) вешается на DOM событие, то нужно переопределять его, не отдавая во вне объект DOM события. Например, компонент поля ввода в событии onChange должен вернуть значение поля.

  


onChange\(e\) =&gt; {

if \(this.props.onChange\){

this.props.onChange\(e.target.value\);

}

}

  


&lt;input onChange={this.onChange} value={this.props.value}&gt;

  


Чтобы не проверять, определено ли необязательное свойство в this.props, рекомендуется описывать значения по умолчанию после определения propTypes

  


static propTypes = {

onChange: PropTypes.func

}

  


static defaultProps = {  
onChange: \(\)=&gt;{}

}

  


